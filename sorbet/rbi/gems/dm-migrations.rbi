# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dm-migrations/all/dm-migrations.rbi
#
# dm-migrations-1.2.0
module DataMapper
  extend DataMapper::Migrations::SingletonMethods
end
module DataMapper::Migrations
  def self.include_migration_api; end
end
module DataMapper::Migrations::SingletonMethods
  def auto_migrate!(repository_name = nil); end
  def auto_migrate_down!(repository_name); end
  def auto_migrate_up!(repository_name); end
  def auto_upgrade!(repository_name = nil); end
  def migrate!(repository_name = nil); end
  def repository_execute(method, repository_name); end
end
module DataMapper::Migrations::Repository
  def auto_migrate!; end
  def auto_upgrade!; end
  def create_model_storage(model); end
  def destroy_model_storage(model); end
  def storage_exists?(storage_name); end
  def upgrade_model_storage(model); end
end
module DataMapper::Migrations::Model
  def auto_migrate!(repository_name = nil); end
  def auto_migrate_down!(repository_name = nil); end
  def auto_migrate_up!(repository_name = nil); end
  def auto_upgrade!(repository_name = nil); end
  def self.included(mod); end
  def storage_exists?(repository_name = nil); end
end
module DataMapper::Adapters
  def self.auto_migration_extensions(const_name); end
  def self.include_migration_api(const_name); end
  def self.migration_module(const_name); end
  extend Anonymous_Module_5
end
module Anonymous_Module_5
  def const_added(const_name); end
end
class DataMapper::Repository
  include DataMapper::Migrations::Repository
end
module DataMapper::Model
  include DataMapper::Migrations::Model
end
class DataMapper::Migrations::DuplicateMigration < StandardError
end
module SQL
end
class SQL::TableCreator
  def column(name, type, opts = nil); end
  def initialize(adapter, table_name, opts = nil, &block); end
  def now; end
  def opts; end
  def opts=(arg0); end
  def quoted_table_name; end
  def table_name; end
  def table_name=(arg0); end
  def to_sql; end
  def uuid; end
  extend DataMapper::Property::Lookup
end
class SQL::TableCreator::SqlExpr
  def initialize(sql); end
  def sql; end
  def sql=(arg0); end
  def to_s; end
end
class SQL::TableCreator::Column
  def build_type(type_class); end
  def initialize(adapter, name, type, opts = nil); end
  def name; end
  def name=(arg0); end
  def quoted_name; end
  def to_sql; end
  def type; end
  def type=(arg0); end
end
class SQL::TableModifier
  def adapter; end
  def adapter=(arg0); end
  def add_column(name, type, opts = nil); end
  def change_column(name, type, opts = nil); end
  def drop_column(name); end
  def drop_columns(name); end
  def initialize(adapter, table_name, opts = nil, &block); end
  def opts; end
  def opts=(arg0); end
  def quote_column_name(name); end
  def quoted_table_name; end
  def rename_column(name, new_name, opts = nil); end
  def statements; end
  def statements=(arg0); end
  def table_name; end
  def table_name=(arg0); end
  def to_sql; end
  extend DataMapper::Property::Lookup
end
class SQL::Column
  def default_value; end
  def default_value=(arg0); end
  def name; end
  def name=(arg0); end
  def not_null; end
  def not_null=(arg0); end
  def primary_key; end
  def primary_key=(arg0); end
  def type; end
  def type=(arg0); end
  def unique; end
  def unique=(arg0); end
end
class SQL::Table
  def column(column_name); end
  def columns; end
  def columns=(arg0); end
  def name; end
  def name=(arg0); end
  def to_s; end
end
module SQL::Sqlite
  def change_column_type_statement(*args); end
  def recreate_database; end
  def supports_schema_transactions?; end
  def supports_serial?; end
  def table(table_name); end
  def table_options(opts); end
end
class SQL::Sqlite::Table < SQL::Table
  def initialize(adapter, table_name); end
end
class SQL::Sqlite::Column < SQL::Column
  def initialize(col_struct); end
end
module SQL::Mysql
  def change_column_type_statement(name, column); end
  def property_schema_statement(connection, schema); end
  def recreate_database; end
  def supports_schema_transactions?; end
  def supports_serial?; end
  def table(table_name); end
  def table_options(opts); end
end
class SQL::Mysql::Table
  def initialize(adapter, table_name); end
end
class SQL::Mysql::Column
  def initialize(col_struct); end
end
module SQL::Postgres
  def change_column_type_statement(name, column); end
  def property_schema_statement(connection, schema); end
  def recreate_database; end
  def supports_schema_transactions?; end
  def supports_serial?; end
  def table(table_name); end
  def table_options(opts); end
end
class SQL::Postgres::Table < SQL::Table
  def initialize(adapter, table_name); end
  def query_column_constraints; end
end
class SQL::Postgres::Column < SQL::Column
  def initialize(col_struct); end
end
class DataMapper::Migration
  def <=>(other); end
  def adapter; end
  def create_index(table_name, *columns_and_options); end
  def create_migration_info_table_if_needed; end
  def create_table(table_name, opts = nil, &block); end
  def database; end
  def down(&block); end
  def drop_table(table_name, opts = nil); end
  def execute(sql, *bind_values); end
  def initialize(position, name, options = nil, &block); end
  def migration_info_table; end
  def migration_info_table_exists?; end
  def migration_name_column; end
  def migration_record; end
  def modify_table(table_name, opts = nil, &block); end
  def name; end
  def needs_down?; end
  def needs_up?; end
  def perform_down; end
  def perform_up; end
  def position; end
  def quote_column_name(column_name); end
  def quote_table_name(table_name); end
  def quoted_name; end
  def repository; end
  def say(message, indent = nil); end
  def say_with_time(message, indent = nil); end
  def setup!; end
  def setup?; end
  def up(&block); end
  def update_migration_info(direction); end
  def write(text = nil); end
  include SQL
end
module DataMapper::Migrations::DataObjectsAdapter
  def create_model_storage(model); end
  def destroy_model_storage(model); end
  def field_exists?(storage_name, column_name); end
  def storage_exists?(storage_name); end
  def upgrade_model_storage(model); end
  include DataMapper::Migrations::DataObjectsAdapter::SQL
end
module DataMapper::Migrations::DataObjectsAdapter::SQL
  def add_column_statement; end
  def alter_table_add_column_statement(connection, table_name, schema_hash); end
  def create_index_statement(model, index_name, fields); end
  def create_index_statements(model); end
  def create_table_statement(connection, model, properties); end
  def create_unique_index_statements(model); end
  def drop_table_statement(model); end
  def indexes(model); end
  def property_schema_hash(property); end
  def property_schema_statement(connection, schema); end
  def schema_name; end
  def supports_drop_table_if_exists?; end
  def supports_serial?; end
  def unique_indexes(model); end
end
module DataMapper::Migrations::DataObjectsAdapter::ClassMethods
  def type_map; end
end
module DataMapper::Migrations::PostgresAdapter
  def create_model_storage(model); end
  def destroy_model_storage(model); end
  def self.included(base); end
  def upgrade_model_storage(model); end
  include DataMapper::Migrations::DataObjectsAdapter
  include DataMapper::Migrations::PostgresAdapter::SQL
end
module DataMapper::Migrations::PostgresAdapter::SQL
  def integer_column_statement(range); end
  def postgres_version; end
  def property_schema_hash(property); end
  def schema_name; end
  def serial_column_statement(range); end
  def supports_drop_table_if_exists?; end
  def without_notices; end
end
module DataMapper::Migrations::PostgresAdapter::ClassMethods
  def type_map; end
end
module DataMapper::Migrations::SqliteAdapter
  def field_exists?(storage_name, column_name); end
  def self.included(base); end
  def storage_exists?(storage_name); end
  include DataMapper::Migrations::DataObjectsAdapter
  include DataMapper::Migrations::SqliteAdapter::SQL
end
module DataMapper::Migrations::SqliteAdapter::SQL
  def create_table_statement(connection, model, properties); end
  def property_schema_statement(connection, schema); end
  def sqlite_version; end
  def supports_drop_table_if_exists?; end
  def supports_serial?; end
  def table_info(table_name); end
end
module DataMapper::Migrations::SqliteAdapter::ClassMethods
  def type_map; end
end
